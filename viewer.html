<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>My Star - てのひら星座工房</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@400;700&display=swap');
    
    body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(circle at center, #1b2735 0%, #090a0f 100%);
      color: white;
      font-family: "Zen Maru Gothic", sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    #starCanvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }

    .ui-layer {
      position: relative;
      z-index: 10;
      text-align: center;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      height: 100%;
      justify-content: space-between;
      padding: 40px 20px;
      box-sizing: border-box;
    }

    h1 {
      font-size: 20px;
      letter-spacing: 2px;
      text-shadow: 0 0 10px rgba(255,255,255,0.5);
      margin: 0;
      opacity: 0;
      animation: fadeIn 2s ease forwards 0.5s;
    }

    .date-label {
      font-size: 12px;
      color: rgba(255,255,255,0.6);
      margin-top: 8px;
      opacity: 0;
      animation: fadeIn 2s ease forwards 0.8s;
    }

    .footer-hint {
      font-size: 12px;
      color: rgba(255,255,255,0.4);
      background: rgba(0,0,0,0.3);
      padding: 8px 16px;
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,0.1);
      opacity: 0;
      animation: fadeIn 2s ease forwards 1.5s;
    }

    @keyframes fadeIn {
      to { opacity: 1; }
    }

    .bg-star {
      position: absolute;
      background: white;
      border-radius: 50%;
      opacity: 0;
      animation: twinkle var(--duration) ease-in-out infinite;
      animation-delay: var(--delay);
    }

    @keyframes twinkle {
      0%, 100% { opacity: 0.2; transform: scale(0.8); }
      50% { opacity: 0.8; transform: scale(1.2); }
    }
  </style>
</head>
<body>

  <canvas id="starCanvas"></canvas>
  <div id="starsContainer"></div>

  <div class="ui-layer">
    <div>
      <h1>私の星座</h1>
      <div class="date-label" id="dateText"></div>
    </div>
    <div class="footer-hint">スクリーンショットで保存してください</div>
  </div>

<script>
  // === 1. 核心算法：计算连线 (从主程序移植) ===
  function computeConstellationEdges(pts, maxDistance){
    if(!pts || pts.length < 2) return [];
    const n = pts.length;
    const edges = [];
    
    // 生成所有可能的连线
    for(let i=0;i<n;i++){
      for(let j=i+1;j<n;j++){
        const dx = pts[j].x - pts[i].x;
        const dy = pts[j].y - pts[i].y;
        edges.push({i,j,dist:Math.hypot(dx,dy)});
      }
    }
    edges.sort((a,b)=>a.dist-b.dist);

    // 最小生成树 (确保所有点连通)
    const parent = new Array(n).fill(0).map((_,i)=>i);
    const find = x => parent[x]===x ? x : (parent[x]=find(parent[x]));
    const unite = (a,b) => { parent[find(a)] = find(b); };

    const chosen = [];
    const usedPairs = new Set();

    // 优先连接最近的点
    for(const e of edges){
      if(find(e.i) !== find(e.j)){
        unite(e.i,e.j);
        chosen.push(e);
        usedPairs.add(`${e.i}-${e.j}`);
      }
    }

    // 添加额外的边以形成闭环或更稳固的结构
    const degree = new Array(n).fill(0);
    for(const e of chosen){ degree[e.i]++; degree[e.j]++; }

    let extraAdded = 0;
    const MAX_EXTRA = n; // 允许添加一些额外的边
    
    for(const e of edges){
      if(extraAdded >= MAX_EXTRA) break;
      const key = `${e.i}-${e.j}`;
      if(usedPairs.has(key)) continue;
      // 距离限制：太远的不要连
      if(maxDistance && e.dist > maxDistance) continue;
      // 度数限制：同一个点不要连太多线
      if(degree[e.i]>=4 || degree[e.j]>=4) continue;

      chosen.push(e);
      usedPairs.add(key);
      degree[e.i]++; degree[e.j]++;
      extraAdded++;
    }
    return chosen;
  }

  // === 2. 数据解析部分 ===
  function expand(flatArray) {
    if (!flatArray || flatArray.length === 0) return [];
    const points = [];
    for (let i = 0; i < flatArray.length; i += 2) {
      points.push({ x: flatArray[i], y: flatArray[i+1] });
    }
    return points;
  }

  const urlParams = new URLSearchParams(window.location.search);
  const binId = urlParams.get('id');
  const compressedData = urlParams.get('d');
  const API_KEY = '$2a$10$H56XRVSRijO/AVt8OmmhKeRKR4gYZqqxtyeYFd0dpvTKy2UQdhIma'; // 你的Key

  if (binId) {
    document.querySelector('h1').innerText = "星を読み込んでいます...";
    fetch(`https://api.jsonbin.io/v3/b/${binId}`, {
      method: 'GET', headers: { 'X-Master-Key': API_KEY }
    })
    .then(r => r.json())
    .then(result => {
      const raw = result.record;
      document.querySelector('h1').innerText = "私の星座";
      const data = {
        d: raw.d,
        p: expand(raw.p),
        s: (raw.s || []).map(stroke => expand(stroke))
      };
      if(data.d) document.getElementById('dateText').innerText = data.d;
      initVisuals(data);
    })
    .catch(e => { console.error(e); document.querySelector('h1').innerText = "通信エラー"; });
  } else if (compressedData) {
    // 兼容旧版
    try {
      const json = LZString.decompressFromEncodedURIComponent(compressedData);
      const raw = JSON.parse(json);
      const data = { d: raw.d, p: raw.p, s: raw.s };
      initVisuals(data);
    } catch(e){}
  } else {
    document.querySelector('h1').innerText = "データなし";
  }

  // === 3. 视觉渲染部分 ===
  function initVisuals(data) {
    const canvas = document.getElementById('starCanvas');
    const ctx = canvas.getContext('2d');
    
    let W = window.innerWidth;
    let H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;

    // 计算缩放和居中
    const allPoints = [...data.p];
    data.s.forEach(path => allPoints.push(...path));

    let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
    allPoints.forEach(p => {
      if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x;
      if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y;
    });

    const contentW = maxX - minX;
    const contentH = maxY - minY;
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    
    // 留出 30% 边距，不让图太大
    const scale = Math.min(W * 0.7 / contentW, H * 0.6 / contentH);

    // 【关键】计算连线！阈值设为包围盒尺寸的 15%
    const maxDist = Math.max(contentW, contentH) * 0.15; 
    const edges = computeConstellationEdges(data.p, maxDist);

    let tiltX=0, tiltY=0;
    let offsetX=0, offsetY=0;

    window.addEventListener('deviceorientation', (e) => {
      if(e.gamma!=null) tiltX = e.gamma * 0.5;
      if(e.beta!=null) tiltY = (e.beta - 45) * 0.5;
    });
    window.addEventListener('mousemove', (e) => {
      tiltX = (e.clientX - W/2)/20; tiltY = (e.clientY - H/2)/20;
    });

    function draw() {
      ctx.clearRect(0, 0, W, H);
      offsetX += (tiltX - offsetX) * 0.1;
      offsetY += (tiltY - offsetY) * 0.1;

      ctx.save();
      ctx.translate(W/2 + offsetX, H/2 + offsetY);
      ctx.scale(scale, scale);
      ctx.translate(-centerX, -centerY);

      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      // 1. 绘制连线 (复刻主程序样式)
      // 底层粗线 (微弱光晕)
      ctx.lineWidth = 4.5;
      ctx.strokeStyle = "rgba(255,255,255,0.15)";
      edges.forEach(e => {
        const p1 = data.p[e.i];
        const p2 = data.p[e.j];
        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
      });

      // 顶层细线 (高亮)
      ctx.lineWidth = 1.2;
      ctx.strokeStyle = "rgba(255,255,255,0.7)";
      ctx.shadowBlur = 0; // 手机端性能考虑，稍微减少模糊
      edges.forEach(e => {
        const p1 = data.p[e.i];
        const p2 = data.p[e.j];
        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
      });

      // 2. 绘制笔触 (绘画轨迹)
      data.s.forEach(path => {
        if(path.length < 2) return;
        // 笔触光晕
        ctx.beginPath();
        ctx.moveTo(path[0].x, path[0].y);
        path.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.lineWidth = 6;
        ctx.strokeStyle = "rgba(100, 200, 255, 0.1)";
        ctx.stroke();

        // 笔触实线
        ctx.beginPath();
        ctx.moveTo(path[0].x, path[0].y);
        path.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.lineWidth = 2;
        ctx.strokeStyle = "rgba(230, 245, 255, 0.85)";
        ctx.stroke();
      });

      // 3. 绘制星座顶点 (三层光晕结构)
      data.p.forEach(p => {
        // 大光晕
        ctx.beginPath(); ctx.arc(p.x, p.y, 14, 0, Math.PI*2);
        ctx.fillStyle = "rgba(160,200,255,0.08)"; ctx.fill();
        
        // 中光晕
        ctx.beginPath(); ctx.arc(p.x, p.y, 8, 0, Math.PI*2);
        ctx.fillStyle = "rgba(220,240,255,0.28)"; ctx.fill();

        // 核心亮星
        ctx.beginPath(); ctx.arc(p.x, p.y, 3.5, 0, Math.PI*2);
        ctx.fillStyle = "#ffffff"; 
        ctx.shadowColor="white"; ctx.shadowBlur=10;
        ctx.fill();
        ctx.shadowBlur=0; // 重置
      });

      ctx.restore();
      requestAnimationFrame(draw);
    }
    
    draw();
    createBackgroundStars();
  }

  function createBackgroundStars() {
    const container = document.getElementById('starsContainer');
    container.innerHTML = ''; // 清空旧的
    for(let i=0; i<50; i++) {
      const star = document.createElement('div');
      star.className = 'bg-star';
      const size = Math.random() * 2 + 1;
      star.style.width = size + 'px';
      star.style.height = size + 'px';
      star.style.left = Math.random() * 100 + '%';
      star.style.top = Math.random() * 100 + '%';
      star.style.setProperty('--duration', (Math.random() * 3 + 2) + 's');
      star.style.setProperty('--delay', (Math.random() * 5) + 's');
      container.appendChild(star);
    }
  }

  window.addEventListener('resize', () => location.reload());
</script>
</body>
</html>